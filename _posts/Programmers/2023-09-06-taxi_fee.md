---
layout: single
title:  "í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - í•©ìŠ¹ íƒì‹œ ìš”ê¸ˆ (Lv.3)"
excerpt: "2021 KAKAO BLIND RECRUITMENT, ë‹¤ìµìŠ¤íŠ¸ë¼"

categories:
  - Programmers
# tags:
#   - [ML, Python]

toc: true
toc_sticky: true
---

## ë¬¸ì œ ë§í¬
- ğŸ‘‰ [í•©ìŠ¹ íƒì‹œ ìš”ê¸ˆ](https://school.programmers.co.kr/learn/courses/30/lessons/72413)

## ë¬¸ì œ ì„¤ëª…
- Nê°œì˜ ì •ì ì´ ìˆê³ , ê° ì •ì ì€ ì„œë¡œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ê·¸ë˜í”„ í˜•íƒœë¥¼ ì·¨í•˜ê³  ìˆë‹¤.
- ì¶œë°œì§€ì (S)ì™€ ë‘ ì‚¬ëŒì˜ ëª©ì ì§€(A,B)ê°€ ì£¼ì–´ì§„ë‹¤.
- ë‘ ì‚¬ëŒì´ ì„œë¡œì˜ ëª©ì ì§€ì— ê°€ëŠ” ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
    - í•©ìŠ¹ì„ í†µí•´ ì¤‘ê°„ ì§€ì ê¹Œì§€ ê°™ì´ ì´ë™í•œë‹¤.
    - ì¤‘ê°„ ì§€ì ì—ì„œ ì„œë¡œì˜ ëª©ì ì§€ë¡œ ê°ì ì´ë™í•œë‹¤.
    - í•©ìŠ¹ì„ í•˜ì§€ ì•Šê³  ì²˜ìŒë¶€í„° ê°ì ì´ë™í•  ìˆ˜ ìˆë‹¤.

## ë¬¸ì œ ì ‘ê·¼1
- **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**
    - ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê·¸ë˜í”„ì˜ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- í•©ìŠ¹í•´ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ë¡œë¥¼ **DFS** ë¥¼ ì´ìš©í•´ êµ¬í•œë‹¤.
- í•©ìŠ¹ì„ í†µí•´ ì´ë™í•œ ì¤‘ê°„ ì§€ì ì—ì„œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì„œë¡œì˜ ëª©ì ì§€ê¹Œì§€ ê°€ëŠ” ìµœì†Œ ë¹„ìš©ì„ ê³„ì‚°í•œë‹¤.
- ìœ„ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ì™„ì „ íƒìƒ‰ì„ í•˜ê³ , ìµœì†Œê°€ ë˜ëŠ” ê°’ì„ ë°˜í™˜í•œë‹¤.

### êµ¬í˜„(ì •í™•ì„± All Pass, íš¨ìœ¨ì„± All Fail)
```c++
#include <string>
#include <vector>
#include <iostream>
#include <queue>
#include <memory.h>
#include <algorithm>

#define INF 9e8

using namespace std;
// w = table[u].first, v = table[u].second
vector<pair<int, int>> table[201];
int cand[201][201]; // cand[v][u] ëŠ” vê°€ uì—ì„œ ì™”ì„ ë•Œ ë¹„ìš©
int answer = INF;
int N, A, B;
int cost[201];
bool visited[201];

void dijkstra(int start, int curCost){
    for(int i=0; i<=N; i++){
        cost[i]=INF;
    }
    cost[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push(make_pair(0, start));
    
    while(!pq.empty()){
        int u = pq.top().second;
        int w = pq.top().first;
        pq.pop();
        
        for(int i=0; i<table[u].size(); i++){
            int v = table[u][i].second;
            int x = table[u][i].first;
            if(w+x < cost[v]){
                cost[v] = w+x;
                pq.push(make_pair(w+x, v));
            }
        }
    }
    
    // í•©ìŠ¹ì§€ì ê¹Œì§€ì˜ ë¹„ìš© + (A, B ì§€ì ê¹Œì§€ì˜ ë¹„ìš©)
    int totalCost = curCost + cost[A] + cost[B];
    answer = min(answer, totalCost);
    // printf("%d -> %d(a) : %d\n", start, A, cost[A]);
    // printf("%d -> %d(b) : %d\n", start, B, cost[B]);
    // printf("current cost: %d\n", curCost);
    // printf("total cost: %d\n",answer);
}

void taxiProcess(int u, int weight){
    for(int i=0; i<table[u].size(); i++){
        int v = table[u][i].second;
        int w = table[u][i].first;
        if(visited[v]) continue;
        visited[v] = true;
        dijkstra(v, weight+w);
        taxiProcess(v, weight+w);
        visited[v] = false;
    }
}

int solution(int n, int s, int a, int b, vector<vector<int>> fares) {
    
    N = n; A = a; B = b;
    for(int i=0; i<fares.size(); i++){
        int u = fares[i][0];
        int v = fares[i][1];
        int w = fares[i][2];
        table[u].push_back(make_pair(w, v));
        table[v].push_back(make_pair(w, u));
    }
    memset(visited, false, sizeof(visited));
    dijkstra(s, 0); // í•©ìŠ¹í•˜ì§€ ì•ŠëŠ” ê²½ìš°
    taxiProcess(s, 0);
    
    return answer;
}
```

## ë¬¸ì œ ì ‘ê·¼ 2
- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì•„ë˜ì™€ ê°™ì´ ì ìš©í•œë‹¤.
    - (`start -> mid` ê¹Œì§€ ë¹„ìš©) + (`mid->a` ê¹Œì§€ ë¹„ìš©) + (`mid->b` ê¹Œì§€ ë¹„ìš©) ì„ êµ¬í•´ì„œ ìµœì†Ÿê°’ì„ ì°¾ëŠ”ë‹¤.

### êµ¬í˜„(íš¨ìœ¨ì„± 7,8ë²ˆ Fail)
```c++
#include <vector>
#include <iostream>
#include <queue>
#include <algorithm>

#define INF 1000000

using namespace std;
// w = table[u].first, v = table[u].second
int N;
vector<pair<int, int>> table[201];
int cost[201];

int dijkstra(int start, int target){
    for(int i=1; i<=N; i++){
        cost[i]=INF;
    }
    cost[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    
    while(!pq.empty()){
        int u = pq.top().second;
        int w = pq.top().first;
        pq.pop();
        if(cost[u] < w) continue;
        for(int i=0; i<table[u].size(); i++){
            int v = table[u][i].second;
            int x = table[u][i].first;
            if(w+x < cost[v]){
                cost[v] = w+x;
                pq.push(make_pair(w+x, v));
            }
        }
    }
    return cost[target];
}

int solution(int n, int s, int a, int b, vector<vector<int>> fares) {
    int ret = INF;
    N = n;
    for(int i=0; i<fares.size(); i++){
        int u = fares[i][0];
        int v = fares[i][1];
        int w = fares[i][2];
        table[u].push_back(make_pair(w, v));
        table[v].push_back(make_pair(w, u));
    }
    // í•©ìŠ¹í•˜ì§€ ì•ŠëŠ” ê²½ìš°
    ret = dijkstra(s, a) + dijkstra(s,b);
    for(int i=1; i<=n; i++){
        if(s!=i) 
            ret = min(ret, dijkstra(s,i) + dijkstra(i, a) + dijkstra(i, b));
    }
    return ret;
}
```

## ë³´ì™„ ë‚´ìš©
- 2ë²ˆì§¸ í’€ì´ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì´ `3xN + 2` ë²ˆ í•´ì•¼í•œë‹¤.
- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ì‹œì‘ì  sì—ì„œ ëª¨ë“  ì ì— ëŒ€í•´ì„œ 1ë²ˆ, aì—ì„œ ëª¨ë“  ì ì— ëŒ€í•´ì„œ 1ë²ˆ, bì—ì„œ ëª¨ë“  ì ì— ëŒ€í•´ì„œ 1ë²ˆìœ¼ë¡œ ì´ 3ë²ˆë§Œ ì§„í–‰í•  ìˆ˜ ìˆë‹¤.
    - 2ì°¨ì› ë°°ì—´ì˜ í˜•íƒœë¡œ 0í–‰ì€ ì‹œì‘ì  sì—ì„œ ëª¨ë“  ë…¸ë“œë¡œ ê°€ëŠ” ìµœì†Œë¹„ìš©ì„ ë‹´ëŠ”ë‹¤.
    - 1í–‰ì€ aì—ì„œ ëª¨ë“  ë…¸ë“œë¡œ ê°€ëŠ” ìµœì†Œë¹„ìš©ì„ ë‹´ëŠ”ë‹¤.
    - 2í–‰ì€ bì—ì„œ ëª¨ë“  ë…¸ë“œë¡œ ê°€ëŠ” ìµœì†Œë¹„ìš©ì„ ë‹´ëŠ”ë‹¤.
    - ë¬´ë°©í–¥ ê·¸ë˜í”„ì´ë¯€ë¡œ ì¶œë°œì§€ì™€ ë„ì°©ì§€ì˜ ê´€ê³„ëŠ” ì¤‘ìš”í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ê°€ëŠ¥í•œ í’€ì´ì´ë‹¤.
        - ë°©í–¥ ê·¸ë˜í”„ì˜€ë‹¤ë©´ 2ì°¨ì› ë°°ì—´ì— ë‹´ê¸´ ì˜ë¯¸ê°€ ë‹¬ë¼ì§„ë‹¤. ì¦‰, sì—ì„œ 1ë²ˆ ë…¸ë“œë¡œ ê°€ëŠ” ìµœì†Œë¹„ìš©ê³¼ 1ë²ˆ ë…¸ë“œì—ì„œ së¡œ ê°€ëŠ” ìµœì†Œë¹„ìš©ì€ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.
        - ë°©í–¥ ê·¸ë˜í”„ì¼ ë•Œ ì´ëŸ° ë°©ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ì´ìœ ëŠ” ì‹œì‘ì ->ì¤‘ê°„ì  ì€ ë°°ì—´ì˜ ì •ì˜ëŒ€ë¡œ ê°€ì§€ë§Œ, ì¤‘ê°„ì ->A í˜¹ì€ Bë¡œ ê°€ëŠ” ê²½ë¡œëŠ” ì¶œë°œì ì´ ì¤‘ê°„ì ì´ê¸° ë•Œë¬¸ì´ë‹¤.

### êµ¬í˜„(All Pass)
```c++
#include <vector>
#include <iostream>
#include <queue>
#include <algorithm>

#define INF 1000000

using namespace std;
// w = table[u].first, v = table[u].second
int N;
vector<pair<int, int>> table[201];
int cost[201];
// s(0), a(1), b(2)
// dList[0][1]~dList[0][200] ì€ së¶€í„° ê° ë…¸ë“œê¹Œì§€ì˜ ìµœì†Œë¹„ìš©
int dList[3][201]; 

void dijkstra(int idx, int start){
    for(int i=1; i<=N; i++){
        dList[idx][i]=INF;
    }
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start});
    dList[idx][start]=0;
    
    while(!pq.empty()){
        int u = pq.top().second;
        int w = pq.top().first;
        pq.pop();
        if(dList[idx][u] < w) continue;
        for(int i=0; i<table[u].size(); i++){
            int v = table[u][i].second;
            int x = table[u][i].first;
            if(w+x < dList[idx][v]){
                dList[idx][v] = w+x;
                pq.push(make_pair(w+x, v));
            }
        }
    }
}

int solution(int n, int s, int a, int b, vector<vector<int>> fares) {
    int ret = INF;
    N = n;
    for(int i=0; i<fares.size(); i++){
        int u = fares[i][0];
        int v = fares[i][1];
        int w = fares[i][2];
        table[u].push_back(make_pair(w, v));
        table[v].push_back(make_pair(w, u));
    }
    dijkstra(0, s);
    dijkstra(1, a);
    dijkstra(2, b);
    ret = dList[1][s] + dList[2][s];
    for(int i=1; i<=n; i++){
        if(dList[0][i]==INF || dList[1][i]==INF || dList[2][i]==INF) continue;
        ret = min(ret, dList[0][i] + dList[1][i] + dList[2][i]);
    }
    
    return ret;
}
```
