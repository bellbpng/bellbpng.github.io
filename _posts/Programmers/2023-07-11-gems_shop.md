---
layout: single
title:  "프로그래머스 - 보석 쇼핑 (Lv.3)"
excerpt: "2020 카카오 인턴십"

categories:
  - Programmers
# tags:
#   - [ML, Python]

toc: true
toc_sticky: true
---

## 문제 링크
- [보석 쇼핑](https://school.programmers.co.kr/learn/courses/30/lessons/67258)

### 구현(시간 초과, Fail)
```c++
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

bool cmp(string s1, string s2){
    return s1<s2;
}

void set_gem_no_overlap(vector<string>& cpy_gems, vector<string>& gems_no_overlap){
    string ref = cpy_gems[0];
    gems_no_overlap.push_back(ref);
    for(int i=1; i<cpy_gems.size(); i++){
        if(ref != cpy_gems[i]){
            ref = cpy_gems[i];
            gems_no_overlap.push_back(ref);
        }
    }
}

// 진열대 번호는 1번부터 시작
void set_gems_idx(vector<string>& gems, vector<string>& gems_category, vector<int>& gems_idx){
    for(int dis_num=0; dis_num<gems.size(); dis_num++){
        for(int ctg=0; ctg<gems_category.size(); ctg++){
            if(gems[dis_num] == gems_category[ctg])
                gems_idx[dis_num+1] = ctg;
        }
    }
}

bool check_gems(vector<int>& num_gems){
    for(int i=0; i<num_gems.size(); i++){
        if(num_gems[i]==0) return false;
    }
    return true;
}


vector<int> get_shortest_range(vector<int>& num_gems, vector<int>& gems_idx){
    int len = gems_idx.size();
    int start = 1;
    int end = 1;
    num_gems[gems_idx[start]] += 1;
    
    for(int i=2; i<len; i++){
        int ctg_idx = gems_idx[i];
        num_gems[ctg_idx] += 1;
        if(check_gems(num_gems)==true){
            end = i;
            break;
        }
    }
    
    int nstart;
    int nend;
    while(true){
        nstart = start + 1;
        nend = end;
        int ctg_idx = gems_idx[start];
        num_gems[ctg_idx] -= 1;
        if(check_gems(num_gems)==false){
            nend = end+1;
            num_gems[gems_idx[end]] += 1;
            if(check_gems(num_gems)==false)
                break;
        }
        start = nstart;
    }
    vector<int> ret = {start, end};
    return ret;
}

vector<int> solution(vector<string> gems) {
    vector<int> answer;
    vector<string> cpy_gems = gems;
    sort(cpy_gems.begin(), cpy_gems.end(), cmp); // 오름차순 정렬
    
    vector<string> gems_category;
    set_gem_no_overlap(cpy_gems, gems_category);
    int ctg_len = gems_category.size();
    cout << ctg_len << endl;
    if(ctg_len == 1) {
        answer.push_back(1);
        answer.push_back(1);
        return answer;
    }
    
    // 진열대 번호는 1번부터 시작
    // gems_idx[num]은 num번 진열대에 존재하는 보석의 인덱스값
    vector<int> gems_idx(gems.size()+1, 0);
    set_gems_idx(gems, gems_category, gems_idx);
    
    // 현재 구간에서 존재하는 보석별 개수 (0 ~ ctg_len-1)
    vector<int> num_gems(ctg_len, 0);
    answer = get_shortest_range(num_gems, gems_idx);
    
    return answer;
}

```

#### 개선한 점
- 투포인터를 통한 완전탐색을 할 것. end를 고정하지 말고 끝까지 탐색하여야 함

### 구현(효율성 테스트 TC4, 12, 13, 15 시간초과)
```c++
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

bool cmp(string s1, string s2){
    return s1<s2;
}

void set_gem_no_overlap(vector<string>& cpy_gems, vector<string>& gems_no_overlap){
    string ref = cpy_gems[0];
    gems_no_overlap.push_back(ref);
    for(int i=1; i<cpy_gems.size(); i++){
        if(ref != cpy_gems[i]){
            ref = cpy_gems[i];
            gems_no_overlap.push_back(ref);
        }
    }
}

// 진열대 번호는 1번부터 시작
void set_gems_idx(vector<string>& gems, vector<string>& gems_category, vector<int>& gems_idx){
    for(int dsp_num=0; dsp_num<gems.size(); dsp_num++){
        for(int ctg=0; ctg<gems_category.size(); ctg++){
            if(gems[dsp_num] == gems_category[ctg]){
                gems_idx[dsp_num+1] = ctg;
                break;
            }
        }
    }
}

bool check_gems(vector<int>& num_gems){
    for(int i=0; i<num_gems.size(); i++){
        if(num_gems[i]==0) return false;
    }
    return true;
}


vector<int> get_shortest_range(vector<int>& num_gems, vector<int>& gems_idx){
    int len = gems_idx.size();
    int start = 1;
    int end = 1;
    num_gems[gems_idx[start]] += 1;
    
    for(int i=2; i<len; i++){
        int ctg_idx = gems_idx[i];
        num_gems[ctg_idx] += 1;
        if(check_gems(num_gems)==true){
            end = i;
            break;
        }
    }
    
    vector<int> ret = {start, end};
    int nstart;
    int nend;
    int diff = end - start + 1;
    while(end<len){
        nstart = start + 1;
        nend = end;
        int ctg_idx = gems_idx[start];
        num_gems[ctg_idx] -= 1;
        if(check_gems(num_gems)==false){
            num_gems[ctg_idx] += 1;
            end+=1;
            if(end<len)
                num_gems[gems_idx[end]] += 1;
        }
        else{
            if(diff > (nend-nstart+1)){
                ret[0] = nstart;
                ret[1] = nend;
                diff = nend-nstart+1;
            }
            start = nstart;
        }
    }
    return ret;
}

vector<int> solution(vector<string> gems) {
    vector<int> answer;
    vector<string> cpy_gems = gems;
    sort(cpy_gems.begin(), cpy_gems.end(), cmp); // 오름차순 정렬
    
    vector<string> gems_category;
    set_gem_no_overlap(cpy_gems, gems_category);
    int ctg_len = gems_category.size();
    cout << ctg_len << endl;
    if(ctg_len == 1) {
        answer.push_back(1);
        answer.push_back(1);
        return answer;
    }
    
    // 진열대 번호는 1번부터 시작
    // gems_idx[num]은 num번 진열대에 존재하는 보석의 인덱스값
    vector<int> gems_idx(gems.size()+1, 0);
    set_gems_idx(gems, gems_category, gems_idx);
    
    // 현재 구간에서 존재하는 보석별 개수 (0 ~ ctg_len-1)
    vector<int> num_gems(ctg_len, 0);
    answer = get_shortest_range(num_gems, gems_idx);
    
    return answer;
}

```

