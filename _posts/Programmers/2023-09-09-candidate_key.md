---
layout: single
title:  "ν”„λ΅κ·Έλλ¨Έμ¤ - ν›„λ³΄ν‚¤ (Lv.2)"
excerpt: "2019 KAKAO BLIND RECRUITMENT"

categories:
  - Programmers
# tags:
#   - [ML, Python]

toc: true
toc_sticky: true
---

## λ¬Έμ  λ§ν¬
- π‘‰ [ν›„λ³΄ν‚¤](https://school.programmers.co.kr/learn/courses/30/lessons/42890)

## λ¬Έμ  μ„¤λ…
- κ΄€κ³„ λ°μ΄ν„°λ² μ΄μ¤μ—μ„ λ¦΄λ μ΄μ…μ νν”μ„ μ μΌν•κ² μ‹λ³„ν•  μ μλ” μ†μ„± λλ” μ†μ„±μ μ§‘ν•© μ¤‘ λ‹¤μ λ‘ μ„±μ§μ„ λ§μ΅±ν•λ” κ²ƒμΌ ν›„λ³΄ν‚¤λΌκ³  ν•λ‹¤.
    - μ μΌμ„±: λ¦΄λ μ΄μ…μ— μλ” λ¨λ“  νν”μ— λ€ν•΄ μ μΌν•κ² μ‹λ³„λμ–΄μ•Ό ν•λ‹¤.
    - μµμ†μ„±: μ μΌμ„±μ„ κ°€μ§„ ν‚¤λ¥Ό κµ¬μ„±ν•λ” μ†μ„± μ¤‘ ν•λ‚λΌλ„ μ μ™Έν•λ” κ²½μ° μ μΌμ„±μ΄ κΉ¨μ§€λ” κ²ƒμ„ μλ―Έν•λ‹¤. μ¦‰, λ¦΄λ μ΄μ…μ λ¨λ“  νν”μ„ μ μΌν•κ² μ‹λ³„ν•λ” λ° κΌ­ ν•„μ”ν• μ†μ„±λ“¤λ΅λ§ κµ¬μ„±λμ–΄μ•Ό ν•λ‹¤.
- λ¦΄λ μ΄μ…μ΄ μ£Όμ–΄μ§ λ•, ν›„λ³΄ ν‚¤μ μµλ€ κ°μλ¥Ό κµ¬ν•λΌ.

## λ¬Έμ  μ ‘κ·Ό
- λ¬¶μ„ μ μλ” μ†μ„±λ“¤μ μ΅°ν•©μ„ κµ¬ν•λ‹¤.
    - μ¬κ·€νΈμ¶μ„ ν†µν• μ†μ„±λ“¤μ μ§‘ν•©μ„ μ°Ύλ”λ‹¤.
- μ„μ—μ„ μ°Ύμ€ μ†μ„±λ“¤μ μ§‘ν•© νΉμ€ μ†μ„±μ΄ μ μΌμ„±μ„ λ§μ΅±ν•λ”μ§€ ν™•μΈν•λ‹¤.
    - μ΅°ν•©μ— ν¬ν•¨λ μ†μ„±λ“¤μ΄ κ° ν–‰μ λ°μ΄ν„° λ‹¨μ„κ°€ λμ–΄, λ™μΌν• ν–‰μ΄ μ΅΄μ¬ν•λ”μ§€ ν™•μΈν•λ‹¤.
- μ„μ—μ„ μ°Ύμ€ μ†μ„±λ“¤μ μ΅ν•© νΉμ€ μ†μ„±μ΄ μµμ†μ„±μ„ λ§μ΅±ν•λ”μ§€ ν™•μΈν•λ‹¤.
    - μ†μ„±λ“¤μ€ κ°μκ°€ μ μ€ κ²ƒλ¶€ν„° ν›„λ³΄ν‚¤μ— λ€ν• μ΅°μ‚¬λ¥Ό ν•κ³ , ν›„λ³΄ν‚¤μΈ κ²½μ° `history` λ°°μ—΄μ— λ„£μ–΄λ‘μ–΄ κ΄€λ¦¬ν•΄μ•Ό ν•λ‹¤.
    - λ”°λΌμ„, `history` μ— λ‹΄κΈ°λ” μ†μ„±λ“¤μ μ΅°ν•©μ€ ν•­μƒ μ μΌμ„±κ³Ό μµμ†μ„±μ„ λ§μ΅±ν•λ‹¤.
- μµμ†μ„±μ„ λ§μ΅±ν•λ”μ§€ μ΅°μ‚¬ν•  λ•, μ΅°μ‚¬ λ€μƒμ΄ λλ” λ¬Έμμ—΄μ—μ„ `history` μ μ›μ†λ“¤μ΄ μ΅΄μ¬ν•λ”μ§€λ¥Ό νμ•…ν•λ”λ° substring μ„ μ°Ύλ” λ°©λ²•μΌλ΅ κµ¬ν„ν–μ—λ‹¤. ν•μ§€λ§, μ΄ κ²½μ°μ—λ” ν›„λ³΄ν‚¤κ°€ [0,3] μ΄κ³  μ΅°μ‚¬ν•λ” μ§‘ν•©μ€ [0,2,3] μΌ λ• μµμ†μ„±μ„ μ¬λ°”λ¥΄κ² ν‰κ°€ν•μ§€ λ»ν•κ³  λ„μ–΄κ°€λ” λ¬Έμ κ°€ λ°μƒν–λ‹¤. μ¦‰, μ—°μ†λμ§€ μ•μ€ μ΅°ν•©μ΄λΌλ©΄ μ°Ύμ„ μ μ—†λ” κ²ƒμ΄μ—λ‹¤.
- μ„ λ΅μ§μ€ λ°λ³µλ¬Έμ„ ν†µν•΄ μ§μ ‘ μ›μ† ν•λ‚ν•λ‚λ¥Ό λΉ„κµν•λ©΄μ„ λ¬Έμ λ¥Ό ν•΄κ²°ν•  μ μμ—λ‹¤.

### κµ¬ν„(All Pass)
```c++
#include <string>
#include <vector>
#include <memory.h>
#include <iostream>
#include <algorithm>
using namespace std;

int answer=0, colNum=0;
vector<string> history;
bool visited[8];
vector<int> cand;

bool checkUnique(vector<vector<string>>& relation){
    vector<vector<string>> table;
    for(int r=0; r<relation.size(); r++){
        vector<string> list;
        for(int i=0; i<cand.size(); i++){
            list.push_back(relation[r][cand[i]]);
        }
        table.push_back(list);
        int tuple = 0;
        for(int i=0; i<table.size(); i++){
            int cnt=0;
            for(int j=0; j<table[i].size(); j++){
                if(list[j]==table[i][j]) cnt++;
            }
            if(cnt == list.size()) tuple++;
        }
        if(tuple>1) return false;
    }
    return true;
}

bool checkMinimality(string combi){
    for(int i=0; i<history.size(); i++){
        int cnt = 0;
        for(int j=0; j<history[i].length(); j++){
            for(int k=0; k<combi.length(); k++){
                if(history[i][j] == combi[k]) cnt++;
            }
        }
        if(cnt == history[i].length()) return false;
    }
    return true;
}

void makeCombination(vector<vector<string>>& relation, int v, int n){
    if(cand.size()==n){
        string str;
        for(int i=0; i<cand.size(); i++){
            str.push_back(cand[i] + '0');
        }
        if(checkUnique(relation) && checkMinimality(str)){
            answer++;
            history.push_back(str);
        }
        return;
    }
    
    for(int i=v; i<colNum; i++){
        if(visited[i]) continue;
        visited[i] = true;
        cand.push_back(i);
        makeCombination(relation, i+1, n);
        visited[i] = false;
        cand.pop_back();
    }
}

int solution(vector<vector<string>> relation) {
    colNum = relation[0].size();
    
    for(int i=1; i<=colNum; i++){
        memset(visited, false, sizeof(visited));
        makeCombination(relation, 0, i);
    }
    
    return answer;
}
```
