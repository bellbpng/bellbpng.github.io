---
layout: single
title:  "프로그래머스 - 최고의 집합(Lv.3)"
excerpt: "연습문제"

categories:
  - Programmers
# tags:
#   - [ML, Python]

toc: true
toc_sticky: true
---

## 문제풀이
- 가능한 한 큰 숫자로 많은 제곱이 이루어져야 곱이 최대가 될 것이라고 생각했다.
- (n-1)X(n-2)X(n-3)X ... 와 같이 감소하는 항이 곱해지는 경우 n^2 보다 항상 작은 결과만 얻게 된다.
- 따라서, 가능한 한 큰 숫자로 최대한 많은 제곱을 할 수 있도록 집합을 구성하는 것이 최고의 집합이 된다.

### 구현(All Pass)
```c++
#include <string>
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

int solution(vector<vector<int>> triangle) {
    int answer = 0;
    int n = triangle.size();
    
    vector<vector<int>> dp(n, vector<int>(n,0));
    dp[0][0] = triangle[0][0];
    
    for(int height=1; height<n; height++){
        for(int idx=0; idx<triangle[height].size(); idx++){
            if(idx==0) // 왼쪽 끝에 위치한 경우
                dp[height][idx] = dp[height-1][idx];
            else if(idx==triangle[height].size()-1) // 오른쪽 끝에 위치한 경우
                dp[height][idx] = dp[height-1][idx-1];
            else // 중간에 위치한 경우
                dp[height][idx] = max(dp[height-1][idx], dp[height-1][idx-1]);
            dp[height][idx] += triangle[height][idx];
            
            // Debugging
            // cout << dp[height][idx] << " ";
        }
    }
    
    
    answer = dp[n-1][0];
    for(int i=1; i<triangle[n-1].size(); i++){
        answer = answer < dp[n-1][i] ? dp[n-1][i] : answer;
    }
    
    return answer;
}

```
