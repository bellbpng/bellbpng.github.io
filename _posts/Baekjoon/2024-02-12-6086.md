---
layout: single
title:  "ë°±ì¤€ 6086 - ìµœëŒ€ ìœ ëŸ‰ + ì•Œê³ ë¦¬ì¦˜ í’€ì´ë¥¼ ìœ„í•œ ê°œë… ì •ë¦¬"
excerpt: "êµ¬í˜„, ê·¸ë˜í”„ ì´ë¡ , ì‹œë®¬ë ˆì´ì…˜, ìµœëŒ€ ìœ ëŸ‰"

categories:
  - Baekjoon Solution
# tags:
#   - [ML, Python]

toc: true
toc_sticky: true
---

## ë¬¸ì œë§í¬
- [ë°±ì¤€ 6086](https://www.acmicpc.net/problem/6086)

## ë¬¸ì œì„¤ëª…
- ìì„¸í•œ ì„¤ëª…ì€ ë§í¬ë¥¼ ì°¸ê³ í•œë‹¤.
- ì–‘ë°©í–¥ ê·¸ë˜í”„ì˜ ìµœëŒ€ ìœ ëŸ‰ ë¬¸ì œ
- ë°°ìˆ˜ê´€ì´ ë³‘ë ¬, ì§ë ¬ë¡œ ì—°ê²°ë˜ë©° ë¬¸ì œ ì„¤ëª…ì´ ë‹¤ì†Œ ë³µì¡í•˜ì§€ë§Œ, ê²°ë¡ ì ìœ¼ë¡œ ê° ë…¸ë“œ ê°„ì˜ ì—°ê²° ê´€ê³„ë¥¼ ê³ ë ¤í•˜ì—¬ ëª©ì ì§€ê¹Œì§€ í˜ë ¤ë³´ë‚¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ìœ ëŸ‰ì„ ê³„ì‚°í•˜ëŠ” ë¬¸ì œì´ë‹¤.

## ìµœëŒ€ ìœ ëŸ‰ ë¬¸ì œ ê°œë… ì •ë¦¬
### ì°¸ê³  ë¸”ë¡œê·¸
- [EVEerNew - [ë°±ì¤€] No.6086 - ìµœëŒ€ ìœ ëŸ‰](https://everenew.tistory.com/178)
- [EVEerNew - Networ Flow (ìµœëŒ€ìœ ëŸ‰, ìµœì†Œ ì»·) ì•Œê³ ë¦¬ì¦˜](https://everenew.tistory.com/177)
- [unorderedmap - ìµœëŒ€ ìœ ëŸ‰ ë¬¸ì œ - ì—ë“œëª¬ë“œ-ì¹´í”„-ì•Œê³ ë¦¬ì¦˜](https://unorderedmap.tistory.com/6)

---
- ê·¸ë˜í”„ì—ì„œ ë‘ ì •ì  ì‚¬ì´ì— ì–¼ë§ˆë‚˜ ë§ì€ ìœ ëŸ‰(flow)ì„ ë³´ë‚¼ ìˆ˜ ìˆëŠ”ì§€ ê³„ì‚°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ë„¤íŠ¸ì›Œí¬ ìœ ëŸ‰(Network Flow) í˜¹ì€ ìµœëŒ€ ìœ ëŸ‰(Maximum Flow) ì•Œê³ ë¦¬ì¦˜ì´ë¼ê³  í•œë‹¤.
- ìš©ëŸ‰(Capacity)
    - c(u,v) ëŠ” ì •ì  uì—ì„œ vë¡œ ê°€ëŠ” ê°„ì„ ì˜ ìš©ëŸ‰(ê°€ì¤‘ì¹˜)ë¼ê³  í•œë‹¤.
- ìœ ëŸ‰(Flow)
    - f(u,v)ëŠ” ì •ì  uì—ì„œ vë¡œì˜ ê°„ì„ ì— ì‹¤ì œë¡œ íë¥´ëŠ” ìœ ëŸ‰ì„ ì˜ë¯¸í•œë‹¤.
- ì”ì—¬ ìš©ëŸ‰(Residual Capacity)
    - ê°„ì„ ì˜ ìš©ëŸ‰ê³¼ ìœ ëŸ‰ì˜ ì°¨ì´ë¥¼ ì˜ë¯¸í•œë‹¤.
    - r(u,v) = c(u,v) - f(u,v)
- ì†ŒìŠ¤(source)
    - ìœ ëŸ‰ì´ ì‹œì‘ë˜ëŠ” ì •ì ìœ¼ë¡œ ëª¨ë“  ìœ ëŸ‰ì€ ì†ŒìŠ¤ì—ì„œë¶€í„° ì‹±í¬ë¡œ íë¥´ê²Œ ëœë‹¤.
- ì‹±í¬(sink)
    - ëª¨ë“  ìœ ëŸ‰ì´ ë„ì°©í•˜ëŠ” ì •ì ì´ ì‹±í¬ì´ë‹¤.
    - ë„¤íŠ¸ì›Œí¬ ìœ ëŸ‰ ì•Œê³ ë¦¬ì¦˜ì€ ì†ŒìŠ¤ì—ì„œ ì‹±í¬ë¡œ íë¥¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ìœ ëŸ‰ì„ ê³„ì‚°í•œë‹¤.
- ì¦ê°€ê²½ë¡œ(Aumented Path)
    - ìµœì†Œ 1ì˜ ìœ ëŸ‰ì´ íë¥¼ ìˆ˜ ìˆëŠ” ì¶œë°œì ì—ì„œ ë„ì°©ì ê¹Œì§€ ê°€ëŠ” ê²½
- **í¬ë“œ-í’€ì»¤ìŠ¨ ì•Œê³ ë¦¬ì¦˜(Ford-Fulkerson Algorithm)**
    - ì¦ê°€ê²½ë¡œê°€ ë‚˜ì˜¤ì§€ ì•Šì„ ë•Œê¹Œì§€ ìœ ëŸ‰ì„ ê·¸ë¦¬ë””í•˜ê²Œ(ìµœëŒ€ ì”ì—¬ ìš©ëŸ‰ì— ë§ê²Œ) í˜ë ¤ì£¼ëŠ” ë°©ì‹
    
    ![image](https://github.com/bellbpng/TCP_IP_Socket_Programming/assets/59792046/c9931dc7-f4b8-4e49-b30c-5b54475ff008)
    
    - 1-2-4-7 ê²½ë¡œë¥¼ ì°¾ì€ ê²½ìš° ìœ„ì™€ ê°™ì€ ê·¸ë˜í”„ê°€ ë§Œë“¤ì–´ì§€ê³ , ê°„ì„  1-2ì˜ ìœ ëŸ‰ì´ ìš©ëŸ‰ì— ë„ë‹¬í–ˆìœ¼ë¯€ë¡œ ì¦ê°€ ê²½ë¡œëŠ” ë” ì´ìƒ ê°„ì„  1-2ë¥¼ í¬í•¨í•  ìˆ˜ ì—†ë‹¤.
    - ê°„ì„  1-3ì„ í¬í•¨í•˜ëŠ” ì¦ê°€ ê²½ë¡œì¸ 1-3-6-7ì„ ì°¾ê³ , íë¥¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ìœ ëŸ‰ì¸ 4ë¥¼ í˜ë ¤ì¤€ ê·¸ë¦¼ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
    
    ![image](https://github.com/bellbpng/TCP_IP_Socket_Programming/assets/59792046/a9ef9dd5-2561-4c3d-927f-b5b170e96815)
    
    - ë§ˆì°¬ê°€ì§€ë¡œ ê°„ì„  1-4ë¥¼ í¬í•¨í•˜ëŠ” ì¦ê°€ ê²½ë¡œì¸ 1-4-7ì„ ì°¾ëŠ” ê²½ìš° 4-7 ì— ìœ ëŸ‰ 3ì´ íë¥´ê³  ìˆìœ¼ë¯€ë¡œ ìµœëŒ€ 1ê¹Œì§€ë§Œ ë” í˜ë ¤ì¤„ ìˆ˜ ìˆë‹¤.
    - ì´ëŸ° ìƒíƒœì—ì„œ ìµœëŒ€ ìœ ëŸ‰ì€ 8ì´ ëœë‹¤.
    
    ![image](https://github.com/bellbpng/TCP_IP_Socket_Programming/assets/59792046/859e3e61-fa0c-4701-9451-75e86831448e)
    
    - **ì¤‘ìš”í•œ ì ì€ ì°¾ê²Œ ë˜ëŠ” ì¦ê°€ê²½ë¡œì˜ ìˆœì„œì— ë”°ë¼ ë¯¸ì²˜ ë°œê²¬í•˜ì§€ ëª»í•˜ëŠ” ì¦ê°€ê²½ë¡œê°€ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì´ë‹¤.**
        - 1-2-4-7 ì— íë¥´ëŠ” ìœ ëŸ‰ì„ ìš°íšŒí•  ìˆ˜ ìˆë‹¤ë©´ (1-2-5-7) 1-4-7 ì˜ ìœ ëŸ‰ì„ ëŠ˜ë¦´ ìˆ˜ ìˆì—ˆì„ ê²ƒì´ë‹¤.
        - ì•„ë˜ëŠ” ì‹¤ì œ ê°€ëŠ¥í•œ ìµœëŒ€ ìœ ëŸ‰ì¸ 11ì„ êµ¬í•˜ëŠ” ë°©ë²•ì´ë‹¤.
        
        ![image](https://github.com/bellbpng/TCP_IP_Socket_Programming/assets/59792046/8bdad9cc-cc84-4979-a5b0-fe4b2a4e1d62)
        
- **ì—ë“œëª¬ë“œ-ì¹´í”„ ì•Œê³ ë¦¬ì¦˜**
    - ìœ„ì™€ ê°™ì€ ê°œë…ì€ **ìœ ëŸ‰ ìƒì‡„** ë¥¼ ì ìš©í•˜ì—¬ **ê¸°ì¡´ì˜ ê°„ì„ ê³¼ ë°˜ëŒ€ ë°©í–¥ì¸ ìš©ëŸ‰ì´ 0ì¸ ê°„ì„ ì„ ì¶”ê°€**í•˜ì—¬ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
        - ì–‘ë°©í–¥ ê·¸ë˜í”„ì˜ ê²½ìš° ìš©ëŸ‰ì„ ë˜‘ê°™ì´ ì„¤ì •í•œë‹¤.
        - ë§Œì•½ ê¸°ì¡´ì˜ ê°„ì„ ì— ìœ ëŸ‰ nì´ íë¥´ê³  ìˆë‹¤ë©´ ë°˜ëŒ€ ë°©í–¥ì˜ ê°„ì„ ì—ëŠ” ìœ ëŸ‰ -nì´ íë¥¸ë‹¤ê³  íŒë‹¨í•œë‹¤.
        - ì´ë ‡ê²Œ ë˜ë©´ ë°˜ëŒ€ ë°©í–¥ì˜ ê°„ì„ ì— në§Œí¼ì˜ ì—¬ìœ  ìš©ëŸ‰ì´ ìƒê¸°ë¯€ë¡œ, í•´ë‹¹ ê°„ì„ ì— ìœ ëŸ‰ì„ í˜ë ¤ì¤„ ìˆ˜ ìˆë‹¤.
        - **ë°˜ëŒ€ ë°©í–¥ì˜ ê°„ì„ ì— ìœ ëŸ‰ì´ íë¥¸ë‹¤ == ê¸°ì¡´ ê°„ì„ ì— ìˆë˜ ìœ ëŸ‰ì„ ì·¨ì†Œí•˜ê³  ìš°íšŒí•œë‹¤.**
- ğŸ’¡ **DFS vs BFS**
    - íŠ¹ì • ì¡°ê±´ì— ì˜í•´ ë°œìƒí•˜ëŠ” ìµœì í™” ë¬¸ì œì— ìˆì–´ì„œ BFS ê°€ ìœ ë¦¬í•˜ë‹¤.
    - ë§Œì•½ ë‹¤ìŒê³¼ ê°™ì€ ê·¸ë˜í”„ì—ì„œ DFSë¡œ ì¦ê°€ ê²½ë¡œë¥¼ ì°¾ì•„ê°„ë‹¤ê³  ìƒê°í•´ë³´ì.
    
    ![image](https://github.com/bellbpng/TCP_IP_Socket_Programming/assets/59792046/0f71d400-207f-4eba-9413-b7613cdd515c)
    
    - s->a->b->të¡œì˜ ê²½ë¡œë¥¼ ì¦ê°€ ê²½ë¡œë¡œ ì°¾ì•˜ë‹¤ë©´ ê²½ë¡œ ì¤‘ ìµœì†Ÿê°’ì¸ 1ë§Œì´ ìƒˆë¡œìš´ ìœ ëŸ‰ìœ¼ë¡œ íë¥¼ ê²ƒì´ë‹¤.
    - ì´ì œ DFSë¡œ s->b->a->tì˜ ê²½ë¡œë¥¼ ì°¾ì•˜ë‹¤ë©´ ì´ë²ˆì—ë„ ì¶”ê°€ë˜ëŠ” ìœ ëŸ‰ì€ 1ì¼ ê²ƒì´ë‹¤.
    
    ![image](https://github.com/bellbpng/TCP_IP_Socket_Programming/assets/59792046/4c2eb2fd-09b2-491d-aa7f-c50f81008a50)
    
    - ì¦ê°€ ê²½ë¡œë¥¼ ì°¾ëŠ” ê³¼ì •ì€ sourceì—ì„œ sinkë¡œì˜ ê²½ë¡œ ì¤‘ ë” ì´ìƒ ìœ ëŸ‰ì„ í˜ë ¤ë³´ë‚¼ ìˆ˜ ì—†ì„ ë•Œê¹Œì§€ì´ë¯€ë¡œ s->a->b->tì™€ s->b->a->tì˜ ê²½ë¡œê°€ ë²ˆê°ˆì•„ ì°¾ì•„ì§€ë©´ì„œ ìµœëŒ€ ìœ ëŸ‰ì¸ 1000íšŒ ë™ì•ˆ ë°˜ë³µí•œë‹¤.
    - í•˜ì§€ë§Œ BFSë¥¼ ì‚¬ìš©í•˜ë©´ sourceì—ì„œ sinkë¡œì˜ ìµœë‹¨ ê²½ë¡œë§ŒÂ ì°¾ìœ¼ë¯€ë¡œ ì´ëŸ¬í•œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.

## êµ¬í˜„
```c++
#include <iostream>
#include <vector>
#include <memory.h>
#include <cctype>
#include <queue>
#include <climits>
#include <algorithm>
#define MAX_ARR 52 // ì•ŒíŒŒë²³ ëŒ€ë¬¸ì(0~25) + ì†Œë¬¸ì(26~51)

using namespace std;

int N;
int capacity[MAX_ARR][MAX_ARR];
int flow[MAX_ARR][MAX_ARR];
vector<int> graph[MAX_ARR];

void Init()
{
	memset(capacity, 0, sizeof(capacity));
	memset(flow, 0, sizeof(flow));
}

int GetMaxFlowAmount(int source, int sink)
{
	int retTotalAmount = 0;

	while (true)
	{
		vector<int> parent(MAX_ARR, -1); // ì–´ë–¤ ì •ì ì—ì„œ ì˜¨ê±´ì§€ íˆìŠ¤í† ë¦¬ë¥¼ ì €ì¥
		queue<int> q;
		q.push(source);
		parent[source] = source;
		while (!q.empty())
		{
			int curNode = q.front();
			q.pop();
			for (int i = 0; i < graph[curNode].size(); i++)
			{
				int nextNode = graph[curNode][i];
				if (capacity[curNode][nextNode] - flow[curNode][nextNode] > 0 && parent[nextNode] == -1)
				{
					parent[nextNode] = curNode;
					q.push(nextNode);
				}
			}
		}

		if (parent[sink] == -1) break; // ì¦ê°€ ê²½ë¡œê°€ ì—†ëŠ” ê²½ìš°
		
		int amount = INT_MAX;
		for (int p = sink; p != source; p = parent[p])
		{
			amount = min(amount, capacity[parent[p]][p] - flow[parent[p]][p]);
		}

		// ì¦ê°€ ê²½ë¡œëŠ” ìœ ëŸ‰ ì¦ê°€, ì—­ë°©í–¥ì€ ìœ ëŸ‰ ê°ì†Œ
		for (int p = sink; p != source; p = parent[p])
		{
			flow[parent[p]][p] += amount;
			flow[p][parent[p]] -= amount;
		}

		retTotalAmount += amount;
	}

	return retTotalAmount;
}

int main()
{
	cin.tie(NULL);
	ios_base::sync_with_stdio(false);

	Init();
	cin >> N;
	for (int i = 0; i < N; i++)
	{
		char node1, node2;
		int weight;
		cin >> node1 >> node2 >> weight;

		int idx1, idx2;
		if (isupper(node1))
		{
			idx1 = node1 - 'A';
		}
		else
		{
			idx1 = node1 - 'a' + 26;
		}
		if (isupper(node2))
		{
			idx2 = node2 - 'A';
		}
		else
		{
			idx2 = node2 - 'a' + 26;
		}
		graph[idx1].push_back(idx2);
		graph[idx2].push_back(idx1);
		capacity[idx1][idx2] += weight;
		capacity[idx2][idx1] += weight; // ì—­ë°©í–¥ ê°„ì„  (for ìœ ëŸ‰ ìƒì‡„)
	}
	int ans = GetMaxFlowAmount(0, 25);
	cout << ans << endl;
}
```
